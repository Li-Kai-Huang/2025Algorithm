# Chapter 11: Hash Tables (雜湊表)

## 概述 (Overview)

* 許多應用程式需要支援字典操作 (INSERT, SEARCH, DELETE) 的動態集合 [cite: 170]。例如編譯器中的符號表。
* 雜湊表在實作字典時非常有效率 [cite: 170]。
* 在某些合理假設下，在雜湊表中搜尋元素的預期時間是 $O(1)$ [cite: 170]。然而，最差情況下的搜尋時間是 $\Theta(n)$ [cite: 170]。
* 雜湊表是普通陣列的一種推廣 [cite: 170]。
* 在普通陣列中，我們將鍵為 $k$ 的元素儲存在陣列的第 $k$ 個位置。這稱為直接定址 (direct addressing) [cite: 170]。
* 當我們不想（或不能）為每個可能的鍵分配一個陣列位置時，我們使用雜湊表 [cite: 170]。
* 當實際儲存的鍵數量相對於可能鍵的數量很少時，雜湊表非常有用。例如，書卷獎得主是廣大人群中的少數 [cite: 169]。

## 筆記 (Outline)

* 直接定址表 (Direct-address tables) [cite: 170]
* 雜湊表 (Hash tables) [cite: 170]
* 雜湊函數 (Hash functions) [cite: 170]
* 碰撞處理 (Collision resolution) [cite: 170]
    * 鏈結法 (Chaining) [cite: 170]
    * 開放定址 (Open addressing) [cite: 170]

## 直接定址表 (Direct-Address Tables)

* **適用場景**：當全域 $U$（所有可能鍵的集合）不是太大時。
* **概念**：我們可以使用一個陣列（或直接定址表）來直接儲存元素。
* **表示**：
    * 我們使用一個陣列 `T[0..m-1]`，其中 $m$ 是全域 $U$ 的大小。
    * 每個位置 `T[k]` 指向一個鍵為 $k$ 的元素。
* **操作**：
    * **SEARCH(T, k)**：返回 `T[k]`。時間複雜度 $O(1)$。
    * **INSERT(T, x)**：`T[key[x]] = x`。時間複雜度 $O(1)$。
    * **DELETE(T, x)**：`T[key[x]] = NIL`。時間複雜度 $O(1)$。
* **缺點**：
    * 如果全域 $U$ 非常大，則儲存一個大小為 $|U|$ 的表是不切實際的。
    * 如果實際儲存的鍵數量很少，則大部分表空間會被浪費。

## 雜湊表 (Hash Tables)

* **概念**：當我們處理的鍵範圍非常大，但實際儲存的鍵數量相對較少時，雜湊表是更好的選擇。
* **核心思想**：不是直接使用鍵作為陣列索引，而是使用一個「雜湊函數」$h$，將鍵 $k$ 映射到一個索引 $h(k)$。
* **儲存方式**：將元素儲存在陣列 `T` 的 `h(key)` 位置。
* **碰撞 (Collisions)**：不同的鍵可能映射到相同的雜湊值，這稱為碰撞。雜湊表的性能很大程度上取決於處理碰撞的效率。

### 碰撞處理方法 (Collision Resolution Methods)

#### 1. 鏈結法 (Chaining)

* **概念**：將所有雜湊到相同槽位（`T[j]`）的元素儲存在一個鏈結串列中。
* **結構**：雜湊表 `T` 是一個包含 $m$ 個槽位的陣列，每個槽位是一個鏈結串列的頭部。
* **操作**：
    * **INSERT(T, x)**：將 $x$ 插入到 `T[h(key[x])]` 所指向的鏈結串列的頭部（通常是 O(1) 操作）。
    * **SEARCH(T, k)**：搜尋 `T[h(k)]` 所指向的鏈結串列以查找鍵為 $k$ 的元素。時間複雜度取決於鏈結串列的長度。
    * **DELETE(T, x)**：從 `T[h(key[x])]` 所指向的鏈結串列中刪除 $x$。

* **性能分析**：
    * **載入因子 (Load factor)**：$\alpha = n/m$，其中 $n$ 是儲存的元素數量，$m$ 是雜湊表的槽位數量。
    * **簡單均勻雜湊 (Simple uniform hashing assumption)**：假設任何給定的鍵同樣可能雜湊到任何槽位，獨立於其他鍵雜湊的位置。
    * 在簡單均勻雜湊的假設下，搜尋成功的預期時間是 $O(1+\alpha)$。
    * 在簡單均勻雜湊的假設下，搜尋失敗的預期時間也是 $O(1+\alpha)$。
    * 如果鏈結長度是常數，或者 $\alpha$ 是常數（例如 $m = \Theta(n)$），則平均查找時間為 $O(1)$。

#### 2. 開放定址法 (Open Addressing)

* **概念**：所有元素都儲存在雜湊表本身，而不是使用額外的資料結構（如鏈結串列）。
* **碰撞處理**：當發生碰撞時，探測 (probe) 表中的其他槽位，直到找到一個空槽。
* **雜湊函數**：探測序列由雜湊函數決定。形式為 $h(k, i)$，表示第 $i$ 次探測的槽位，其中 $i$ 從 0 開始。
    * `h(k, 0), h(k, 1), h(k, 2), ..., h(k, m-1)` 必須是 $\{0, 1, ..., m-1\}$ 的排列。
* **操作**：
    * **INSERT(T, k)**：計算 $h(k, 0)$，如果該槽位被佔用，計算 $h(k, 1)$，以此類推，直到找到空槽。
    * **SEARCH(T, k)**：計算 $h(k, 0)$，如果該槽位不是 $k$ 且未空，計算 $h(k, 1)$，以此類推，直到找到 $k$ 或找到空槽（表示 $k$ 不在表中）。
    * **DELETE(T, k)**：刪除在開放定址法中較為複雜。直接將槽位設為空會破壞搜尋鏈，所以通常會將槽位標記為「已刪除」的特殊標記 (dummy value)。
* **探測方法**：
    * **線性探測 (Linear Probing)**：$h(k, i) = (h'(k) + i) \pmod m$
        * **優點**：簡單，容易實作。
        * **缺點**：容易產生「主群集 (primary clustering)」，導致長長的連續已佔用槽位序列，降低性能。
    * **二次探測 (Quadratic Probing)**：$h(k, i) = (h'(k) + c_1 i + c_2 i^2) \pmod m$
        * **優點**：減少主群集問題。
        * **缺點**：會產生「次群集 (secondary clustering)」，所有鍵的初始哈希值相同，它們的探測序列也相同。
    * **雙重雜湊 (Double Hashing)**：$h(k, i) = (h_1(k) + i \cdot h_2(k)) \pmod m$
        * **優點**：提供了最佳的探測序列，因為每個鍵都有一個唯一的探測序列。
        * **缺點**：相對複雜，且要求 $h_2(k)$ 與 $m$ 互質，以確保探測序列涵蓋所有槽位。
* **性能分析**：在均勻散列的假設下，在開放定址法中：
    * 搜尋失敗的預期探測次數為約 $1/(1-\alpha)$。
    * 搜尋成功的預期探測次數為約 $(1/\alpha) \ln(1/(1-\alpha))$。
    * 當 $\alpha$ 接近 1 時，性能會迅速惡化。因此，通常要求 $\alpha \le 0.5$ 或 $0.7$。

## 雜湊函數 (Hash Functions)

* 一個好的雜湊函數應該滿足簡單均勻雜湊的假設：每個鍵同樣可能雜湊到任何槽位，獨立於其他鍵雜湊的位置。
* 實際上很難實現，但目標是讓雜湊值看起來是隨機的。
* **常用方法**：
    * **除法法 (Division Method)**：$h(k) = k \pmod m$
        * **要求**：通常選擇 $m$ 為一個質數，且不要是 2 的冪次方，這樣可以更好地分散鍵。
    * **乘法法 (Multiplication Method)**：
        * $h(k) = \lfloor m(kA \pmod 1)\rfloor$，其中 $A$ 是一個常數，通常取 $0 < A < 1$。
        * 推薦 $A \approx (\sqrt{5}-1)/2 \approx 0.618$。
        * $m$ 通常取 2 的冪次方，這樣計算效率高。
* **通用雜湊 (Universal Hashing)**：
    * 為了避免惡意的輸入導致所有鍵都雜湊到同一槽位（導致最差情況 $O(n)$ 性能），可以使用通用雜湊。
    * 這是一種在運行時隨機選擇雜湊函數的方法。
    * 選擇一個雜湊函數族，使得對於任意兩個不同的鍵，它們發生碰撞的機率都很小。
    * 這可以保證在平均情況下有良好的性能，即使在最差情況下輸入也是隨機的。