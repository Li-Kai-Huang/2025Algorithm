# Chapter 9: Medians and Order Statistics (中位數與順序統計量)

## 概述 (Overview)

* **順序統計量 (Order Statistics)**：
    * $n$ 個元素集合中第 $i$ 小的元素稱為第 $i$ 個順序統計量 [cite: 90]。
    * 最小值是第 1 個順序統計量 ($i=1$) [cite: 90]。
    * 最大值是第 $n$ 個順序統計量 ($i=n$) [cite: 91]。
    * **中位數 (Median)**：集合的「中點」 [cite: 91]。
        * 當 $n$ 為奇數時，中位數是唯一的，位於 $i=(n+1)/2$ [cite: 91]。
        * 當 $n$ 為偶數時，有兩個中位數：下中位數 ($i=\lfloor(n+1)/2\rfloor$) 和上中位數 ($i=\lceil(n+1)/2\rceil$) [cite: 91]。
        * 當我們使用「中位數」一詞時，通常指的是下中位數 [cite: 91]。

## 選擇問題 (The Selection Problem)

* **問題**：如何在一個包含 $n$ 個（不同）數字的集合 $A$ 中找到第 $i$ 個順序統計量，其中 $1 \le i \le n$ [cite: 89]。
* **輸出**：集合 $A$ 中恰好大於 $i-1$ 個其他元素的元素 $x$ [cite: 90]。
* 選擇問題可以在 $O(n \lg n)$ 時間內解決：
    * 使用 $O(n \lg n)$ 時間的演算法（如堆積排序或合併排序）對數字進行排序。
    * 然後返回排序後陣列中的第 $i$ 個元素。
* 本章將介紹一個可以在預期線性時間 $O(n)$ 內找到第 $i$ 小的元素，以及在最差情況下為 $O(n)$ 的演算法 [cite: 89]。

## 尋找最小值 (Finding Minimum)

* 找到 $n$ 個元素集合中最小值的簡單方法是迭代遍歷所有元素 [cite: 89]。
* **演算法**：
    1.  初始化 `min` 為陣列的第一個元素。
    2.  從第二個元素開始，遍歷其餘元素。
    3.  如果當前元素小於 `min`，則更新 `min`。
* **MINIMUM(A) 偽碼**：
    ```
    MINIMUM(A)
    1  min ← A[1]
    2  for i ← 2 to length[A]
    3      do if min > A[i]
    4          then min ← A[i]
    5  return min
    ```
* **時間複雜度**：該演算法進行 $n-1$ 次比較 [cite: 89]。
* **最佳性**：該演算法是最佳的，因為除了最小值之外，每個元素至少必須與一個較小的元素比較一次 [cite: 89]。
* 用相同的方法，將 `>` 替換為 `<` 即可找到最大值。

## 同時尋找最小值和最大值 (Simultaneous Minimum and Maximum)

* 某些應用程式需要同時找到最小值和最大值 [cite: 89]。
* 獨立尋找最小值和最大值，每個需要 $n-1$ 次比較，總共需要 $2n-2$ 次比較 [cite: 89]。
* **更有效的方法**：最多只需要 $3\lfloor n/2\rfloor$ 次比較 [cite: 89]。
    * 維護到目前為止已知的最小值和最大值。
    * **初始值設定**：
        * 如果 $n$ 為偶數，比較前兩個元素，將較大的賦給 `max`，較小的賦給 `min`。這樣進行 1 次比較。
        * 如果 $n$ 為奇數，將第一個元素同時賦給 `min` 和 `max`。這樣進行 0 次比較。
    * **成對處理**：從已處理的元素（如果有）的下一個元素開始，成對處理剩餘元素。
        * 先比較一對中的兩個元素。
        * 然後將較大的元素與目前的總 `max` 比較，將較小的元素與目前的總 `min` 比較。
        * 這樣每處理一對元素需要 3 次比較。
* **比較次數**：
    * 如果 $n$ 為偶數：1 (初始) + $3(n-2)/2$ (成對處理) = $1 + 3n/2 - 3 = 3n/2 - 2$ 次比較。
    * 如果 $n$ 為奇數：0 (初始) + $3(n-1)/2$ (成對處理) = $3(n-1)/2$ 次比較。
    * 無論哪種情況，比較次數都 $\le 3\lfloor n/2\rfloor$ [cite: 89]。

**範例**：
`A = [5, 2, 8, 1, 9, 4, 7, 3]` (n=8, 偶數)

1.  **初始**：比較 `A[1]=5` 和 `A[2]=2`。
    * `min = 2`, `max = 5` (1 次比較)
2.  **成對處理**：從 `A[3]` 開始，每次取兩個元素。
    * 處理 `(8, 1)`：`8 > 1`。
        * `min` 與 `1` 比較：`2 > 1`，更新 `min = 1`。
        * `max` 與 `8` 比較：`5 < 8`，更新 `max = 8`。 (3 次比較)
    * 處理 `(9, 4)`：`9 > 4`。
        * `min` 與 `4` 比較：`1 < 4`，`min` 不變。
        * `max` 與 `9` 比較：`8 < 9`，更新 `max = 9`。 (3 次比較)
    * 處理 `(7, 3)`：`7 > 3`。
        * `min` 與 `3` 比較：`1 < 3`，`min` 不變。
        * `max` 與 `7` 比較：`9 > 7`，`max` 不變。 (3 次比較)

總比較次數：$1 + 3 + 3 + 3 = 10$ 次。
根據公式：$3n/2 - 2 = 3(8)/2 - 2 = 12 - 2 = 10$ 次。

## 線性時間內的選擇 (Selection in Expected Linear Time)

* 第 $i$ 小的元素選擇可以在預期線性時間內完成 [cite: 89]。
* 這通常透過 `RANDOMIZED-SELECT` 演算法來實現，該演算法是基於快速排序中的 `PARTITION` 過程。
* **`RANDOMIZED-SELECT(A, p, r, i)` 演算法**：
    * 輸入：陣列 `A`，子陣列範圍 `[p, r]`，要找的順序統計量 `i`。
    1.  如果 `p == r`，則返回 `A[p]` (只剩一個元素)。
    2.  `q = RANDOMIZED-PARTITION(A, p, r)` (將陣列劃分為兩個子陣列，並返回基準元素的索引 `q`)。
    3.  `k = q - p + 1` (計算基準元素在當前子陣列中的排名)。
    4.  如果 `i == k`，則基準元素 `A[q]` 就是第 $i$ 小的元素，返回 `A[q]`。
    5.  如果 `i < k`，則第 $i$ 小的元素在左子陣列 `A[p..q-1]` 中，遞迴呼叫 `RANDOMIZED-SELECT(A, p, q-1, i)`。
    6.  如果 `i > k`，則第 $i$ 小的元素在右子陣列 `A[q+1..r]` 中，且它是右子陣列中的第 `(i-k)` 小的元素，遞迴呼叫 `RANDOMIZED-SELECT(A, q+1, r, i-k)`。
* **時間複雜度**：
    * **最差情況**：如果每次劃分都產生一個大小為 $n-1$ 的子問題，則時間複雜度為 $O(n^2)$。這類似於快速排序在最差情況下的行為。
    * **最佳情況**：如果每次劃分都能將陣列平分成兩半，則時間複雜度為 $O(n)$。遞迴關係為 $T(n) = T(n/2) + O(n)$。
    * **預期時間 (Average Case)**：$O(n)$。證明這個需要更複雜的機率分析，但直觀上，平均而言，劃分會做得足夠好，使得每次遞迴的規模顯著縮小。

## 最差情況線性時間內的選擇 (Selection in Worst-Case Linear Time)

* 存在一個更複雜的演算法，可以保證在最差情況下也在 $O(n)$ 時間內找到第 $i$ 個順序統計量 [cite: 89]。
* 這個演算法稱為 `SELECT` (或「中位數中的中位數」演算法)。
* **`SELECT(A, p, r, i)` 演算法步驟**：
    1.  將輸入的 $n$ 個元素劃分為 $\lceil n/5 \rceil$ 個組，每組 5 個元素（最後一個組可能少於 5 個）。
    2.  對每組的 5 個元素進行排序（例如，使用插入排序）。找出每組的中位數。
    3.  遞迴地呼叫 `SELECT` 找出這 $\lceil n/5 \rceil$ 個中位數的中位數 $x$。
    4.  使用 $x$ 作為基準元素，對輸入陣列進行劃分 `PARTITION(A, p, r, x)`。假設 $x$ 的索引為 $q$。
    5.  如果 `i == k` (其中 `k` 是 $x$ 的排名)，返回 $x$。
    6.  如果 `i < k`，則遞迴地在左子陣列中尋找第 $i$ 小的元素。
    7.  如果 `i > k`，則遞迴地在右子陣列中尋找第 `(i-k)` 小的元素。
* **時間複雜度**：
    * 步驟 1 和 2：$O(n)$ (每組 5 個元素排序是常數時間)。
    * 步驟 3：遞迴呼叫的規模是 $T(\lceil n/5 \rceil)$。
    * 步驟 4：劃分操作是 $O(n)$。
    * 步驟 5、6、7：遞迴呼叫的規模是 $T(\alpha n)$。
    * **關鍵證明**：可以證明至少有 $3n/10$ 個元素小於 $x$ (或大於 $x$)。因此，遞迴呼叫的規模最多為 $7n/10$。
    * 遞迴關係為 $T(n) \le T(n/5) + T(7n/10) + O(n)$。
    * 解此遞迴關係可得 $T(n) = O(n)$。
* **優點**：保證最差情況時間複雜度為 $O(n)$。
* **缺點**：實際應用中，因為常數因子較大，通常 `RANDOMIZED-SELECT` 表現更好。