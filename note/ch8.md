# Chapter 8: Sorting in Linear Time (線性時間排序)

## 概述 (Overview)

* 一般排序演算法（如合併排序、堆積排序）在最差情況下需要 $O(n \lg n)$ 時間來排序 $n$ 個數字 [cite: 1]。快速排序平均也需要 $O(n \lg n)$ 時間 [cite: 1]。
* 對於這些演算法，可以產生一個 $n$ 個輸入數字的序列，導致演算法在 $\Theta(n \lg n)$ 時間內運行 [cite: 1]。
* **比較排序 (Comparison Sorting)**：
    * 在排序過程中，唯一可用於獲取序列順序資訊的操作是比較元素對 [cite: 1]。
    * 目前所見的所有排序演算法都是比較排序：插入排序、選擇排序、合併排序、快速排序、堆積排序 [cite: 1]。

## 排序下界 (Lower Bounds for Sorting)

* 排序至少需要 $O(n)$ 時間來檢查所有輸入 [cite: 1]。
* 對於比較排序，下界為 $\Omega(n \lg n)$ [cite: 1]。這意味著任何只透過比較元素來排序的演算法，在最差情況下都不可能比 $O(n \lg n)$ 更快 [cite: 1]。

## 線性時間排序演算法 (Linear Time Sorting Algorithms)

* 線性時間排序演算法的時間複雜度為 $O(n)$ [cite: 1]。
* 這些演算法不是比較排序 [cite: 1]，而是利用輸入數字的某些特性來達到更快的速度。
* 本章將介紹：
    * 計數排序 (Counting sort) [cite: 1]
    * 基數排序 (Radix sort) [cite: 1]
    * 桶子排序 (Bucket sort) [cite: 1]

### 計數排序 (Counting Sort)

* **適用條件**：輸入是 $n$ 個在範圍 $[0, k]$ 之間的整數，其中 $k$ 是一個與 $n$ 相近的整數。
* **基本思想**：
    1.  對於每個輸入元素 $x$，確定小於 $x$ 的元素個數。
    2.  利用此信息，將 $x$ 直接放置到其在輸出陣列中的正確位置。
* **步驟**：
    1.  建立一個輔助陣列 `C`，大小為 $k+1$，用於儲存每個輸入值出現的次數。初始化為 0。
    2.  遍歷輸入陣列 `A`，對於每個元素 `A[j]`，將 `C[A[j]]` 增 1。此時 `C[i]` 包含值 `i` 在 `A` 中出現的次數。
    3.  修改陣列 `C`，使得 `C[i]` 包含小於或等於 `i` 的元素個數。這是通過遍歷 `C`，將 `C[i]` 加上 `C[i-1]` 來實現的。
    4.  創建一個輸出陣列 `B`，大小為 $n$。
    5.  從後往前遍歷輸入陣列 `A` (從 `n-1` 到 `0`)。對於每個 `A[j]`：
        * 將 `A[j]` 放到 `B[C[A[j]] - 1]` 的位置。
        * 將 `C[A[j]]` 減 1。這是為了處理重複元素，確保相同的值按其在輸入中出現的順序排列 (穩定性)。
* **時間複雜度**：$O(n+k)$。
    * 如果 $k = O(n)$，則時間複雜度為 $O(n)$。
* **優點**：穩定排序 (preserves the relative order of elements with equal keys)。
* **缺點**：
    * 對輸入數據的範圍有要求 (即 $k$ 不能太大)。
    * 需要額外的空間 $O(k)$。

**範例**：
假設輸入陣列 `A = [2, 5, 3, 0, 2, 3, 0, 3]`，且 $k=5$。

1.  初始化 `C` 陣列（大小 $k+1 = 6$）：`C = [0, 0, 0, 0, 0, 0]`
2.  遍歷 `A` 填充 `C`：
    * `A[0]=2` -> `C = [0, 0, 1, 0, 0, 0]`
    * `A[1]=5` -> `C = [0, 0, 1, 0, 0, 1]`
    * `A[2]=3` -> `C = [0, 0, 1, 1, 0, 1]`
    * `A[3]=0` -> `C = [1, 0, 1, 1, 0, 1]`
    * `A[4]=2` -> `C = [1, 0, 2, 1, 0, 1]`
    * `A[5]=3` -> `C = [1, 0, 2, 2, 0, 1]`
    * `A[6]=0` -> `C = [2, 0, 2, 2, 0, 1]`
    * `A[7]=3` -> `C = [2, 0, 2, 3, 0, 1]`
    * 最終 `C = [2, 0, 2, 3, 0, 1]`
3.  修改 `C` 陣列，使其包含小於或等於 `i` 的元素個數：
    * `C[0] = 2`
    * `C[1] = C[1] + C[0] = 0 + 2 = 2`
    * `C[2] = C[2] + C[1] = 2 + 2 = 4`
    * `C[3] = C[3] + C[2] = 3 + 4 = 7`
    * `C[4] = C[4] + C[3] = 0 + 7 = 7`
    * `C[5] = C[5] + C[4] = 1 + 7 = 8`
    * 最終 `C = [2, 2, 4, 7, 7, 8]`
4.  創建輸出陣列 `B`，並從後往前遍歷 `A`：
    * `A[7]=3`：`C[3]=7`。將 `3` 放入 `B[7-1]` (即 `B[6]`)。`C[3]` 減 1 為 `6`。 `B = [_, _, _, _, _, _, 3, _]`
    * `A[6]=0`：`C[0]=2`。將 `0` 放入 `B[2-1]` (即 `B[1]`)。`C[0]` 減 1 為 `1`。 `B = [_, 0, _, _, _, _, 3, _]`
    * `A[5]=3`：`C[3]=6`。將 `3` 放入 `B[6-1]` (即 `B[5]`)。`C[3]` 減 1 為 `5`。 `B = [_, 0, _, _, _, 3, 3, _]`
    * `A[4]=2`：`C[2]=4`。將 `2` 放入 `B[4-1]` (即 `B[3]`)。`C[2]` 減 1 為 `3`。 `B = [_, 0, _, 2, _, 3, 3, _]`
    * `A[3]=0`：`C[0]=1`。將 `0` 放入 `B[1-1]` (即 `B[0]`)。`C[0]` 減 1 為 `0`。 `B = [0, 0, _, 2, _, 3, 3, _]`
    * `A[2]=3`：`C[3]=5`。將 `3` 放入 `B[5-1]` (即 `B[4]`)。`C[3]` 減 1 為 `4`。 `B = [0, 0, _, 2, 3, 3, 3, _]`
    * `A[1]=5`：`C[5]=8`。將 `5` 放入 `B[8-1]` (即 `B[7]`)。`C[5]` 減 1 為 `7`。 `B = [0, 0, _, 2, 3, 3, 3, 5]`
    * `A[0]=2`：`C[2]=3`。將 `2` 放入 `B[3-1]` (即 `B[2]`)。`C[2]` 減 1 為 `2`。 `B = [0, 0, 2, 2, 3, 3, 3, 5]`

最終排序結果 `B = [0, 0, 2, 2, 3, 3, 3, 5]`。

### 基數排序 (Radix Sort)

* **適用條件**：對多位數進行排序。
* **基本思想**：對數字的每一位進行排序，從最低有效位 (LSD) 到最高有效位 (MSD)。每次排序都使用一個穩定排序演算法（如計數排序）。
* **歷史**：最早用於對穿孔卡片進行排序的機器。
* **步驟**：
    1.  確定數字的最大位數 `d`。
    2.  對於 $i = 1$ 到 $d$ (從最低位到最高位)：
        * 使用一個穩定排序演算法（例如計數排序）對數字的第 $i$ 位進行排序。
* **時間複雜度**：$O(d(n+k))$，其中 $d$ 是數字的最大位數，$k$ 是每個位數的範圍（通常是 0-9，所以 $k=9$）。
    * 如果數字是 $b$ 進制的，最大位數為 $d$，則每個位數的範圍為 $k-1$ (例如 0-9)。
    * 假設所有數字的最大位數為 $d$，且每位數字的範圍為 $k$。則總時間為 $O(d(n+k))$。
    * 如果所有數字都落在 $0$ 到 $n^c-1$ 的範圍內，對於某個常數 $c>0$，我們可以將每個數字表示為 $b$ 進制，其中 $b = n^{1/c}$。那麼每個數字有 $c$ 位數。
    * 使用計數排序作為穩定排序器。
    * 時間複雜度為 $O(c(n+n^{1/c}))$。如果選擇 $c=1$，則為 $O(n)$。如果選擇 $c=2$，則為 $O(2(n+n^{1/2})) = O(n)$。

**範例**：
對以下數字進行基數排序：`[329, 457, 657, 839, 436, 720, 355]`

1.  **第一位 (個位) 排序**（使用計數排序）：
    * `[720, 355, 436, 457, 657, 329, 839]` (注意相同個位數的相對順序)
2.  **第二位 (十位) 排序**：
    * `[720, 329, 839, 436, 355, 457, 657]`
3.  **第三位 (百位) 排序**：
    * `[329, 355, 436, 457, 657, 720, 839]`

最終排序結果：`[329, 355, 436, 457, 657, 720, 839]`。

### 桶子排序 (Bucket Sort)

* **適用條件**：輸入數據是均勻分佈在一個區間內的浮點數。
* **基本思想**：將區間劃分為若干個桶，將元素放入對應的桶中，然後對每個桶內的元素進行排序，最後將所有桶的元素合併。
* **步驟**：
    1.  假設輸入是一組 $n$ 個浮點數，均勻分佈在 $[0, 1)$ 區間。
    2.  創建 $n$ 個桶（鏈結串列）。
    3.  將每個輸入元素 $A[i]$ 放入對應的桶中。例如，將 $A[i]$ 放入桶 `floor(n * A[i])`。
    4.  對每個桶內的元素進行排序（可以使用插入排序，因為如果數據均勻分佈，每個桶的元素數量會很少）。
    5.  依序將所有桶的元素合併。
* **時間複雜度**：平均情況為 $O(n)$。
    * 如果輸入數據是均勻分佈的，每個桶的元素數量較少，插入排序的效率會很高。
* **優點**：適用於均勻分佈的數據。
* **缺點**：
    * 對輸入數據的分佈有要求。
    * 需要額外的空間來儲存桶。

**範例**：
假設輸入陣列 `A = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68]`，`n=10`。

1.  創建 10 個桶（B[0] 到 B[9]）。
2.  將元素放入對應的桶：
    * `0.78` -> `B[7]` (floor(10 * 0.78) = 7)
    * `0.17` -> `B[1]`
    * `0.39` -> `B[3]`
    * `0.26` -> `B[2]`
    * `0.72` -> `B[7]`
    * `0.94` -> `B[9]`
    * `0.21` -> `B[2]`
    * `0.12` -> `B[1]`
    * `0.23` -> `B[2]`
    * `0.68` -> `B[6]`

    桶內容 (未排序)：
    * `B[0]: []`
    * `B[1]: [0.17, 0.12]`
    * `B[2]: [0.26, 0.21, 0.23]`
    * `B[3]: [0.39]`
    * `B[4]: []`
    * `B[5]: []`
    * `B[6]: [0.68]`
    * `B[7]: [0.78, 0.72]`
    * `B[8]: []`
    * `B[9]: [0.94]`

3.  對每個桶內的元素進行排序 (使用插入排序)：
    * `B[1]: [0.12, 0.17]`
    * `B[2]: [0.21, 0.23, 0.26]`
    * `B[3]: [0.39]`
    * `B[6]: [0.68]`
    * `B[7]: [0.72, 0.78]`
    * `B[9]: [0.94]`

4.  合併所有桶的元素：
    `[0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94]`